# конвертация из разных систем исчисления
ALPHABET_MAP = {
    0: '0',
    1: '1',
    2: '2',
    3: '3',
    4: '4',
    5: '5',
    6: '6',
    7: '7',
    8: '8',
    9: '9',
    10: 'a',
    11: 'b',
    12: 'c',
    13: 'd',
    14: 'e',
    15: 'f',
    16: 'g',
    17: 'h',
    18: 'i',
    19: 'k',
    20: 'l',
    21: 'm',
    22: 'n',
    23: 'o',
    24: 'p',
    25: 'q',
    26: 'r',
    27: 's',
    28: 't',
    29: 'v',
    30: 'x',
    31: 'y',
    32: 'z'
}
REVERSE_ALPHABET_MAP = {ALPHABET_MAP[k]: k for k in ALPHABET_MAP}


def convert(num, base):
    # находим число в целевой системы такое что в нем будет минимальное число разрядов и при этом оно будет больше исходного
    # при условии что все разряды выставлены в максимальное значение

    # находим чсло разрядов в целевой системе
    i = 0
    dst_number = 0
    while dst_number < num:
        dst_number += (base - 1) * (base ** i)
        i += 1
    i -= 1

    result = ''
    while i >= 0:
        digit = int(num / base ** i)
        if digit > 9:
            if ALPHABET_MAP.get(digit) is None:
                print('Alphabet is finished.')
                return
            result += ALPHABET_MAP[digit]
        else:
            result += str(digit)

        num -= digit * (base ** i)
        i -= 1
    return result

# tests
# print(convert(9, 2))
# print(convert(255, 16))
# print(convert(255, 255))
# print(convert(255, 2))
# print(convert(255, 10))
# print(convert(125152153153, 255))



# найти все перестановки строки abcde с учетом того что все символы входной строки разные
# просто  представляем символы как цифры в системе исчисления равной длинне заданной строки
# тоесть для данного случая как цифры 0 1 2 3 4 в пятеричной системе исчисления
# ищем минимальное пятизначное число в этой система, для данного случая это будет 01234 и макчимальное 43210
# и идем по циклу от минимального до максимального печая все и выкидывая те где есть повторяющиеся цифры

input_string = 'abc1234567890'
base = len(input_string)

# сколько будет 01234 т 43210 в десятичной системе
# min_ = 4 * (5**0) + 3 * (5**1) +  2 * (5**2) +  1 * (5**3) +  0 * (5**4)
# max_ = 0 * (5**0) + 1 * (5**1) +  2 * (5**2) +  3 * (5**3) +  4 * (5**4)
min_ = sum((base - 1 - power) * (base ** power)  for power in range(base))
max_ = sum(power * (base ** power)  for power in range(base))

for i in range(min_, max_ + 1):
    r = convert(i, base)
    if len(r) == base - 1:
        r = '0' + r
    if len({symbol for symbol in r }) != base:
        # здесь силная просадка по производительности в случае когда начинают повторяться символы в верхних разрадах
        # потому как надо пропуска миллионы значений типа - с 1002345 до 1023456
        # можно подумать как пропустить сразу все 100к но не очевидно как, может лучше просто использовать другой алгоритм
        # с учетом того вто надо еще конвертировать числа из одной системы в другую все конечно по производительности будет не очень
        # так что лучше что то другое сделать
        continue
    print(''.join(input_string[REVERSE_ALPHABET_MAP[symbol]] for symbol in r))


# найти все перестановки строки abb с учетом того что символы входной строки могут повторяться
# теперь не нужно выкидывать те числа в которых проверяется повторяемость чисел в разрядах
# но и при поиске минимума и максимума надо учитывать повторяемость
# ищем максимум и минимум
# то есть для bbccc у нас пятиричная система - минимально число будет 00011 так как "с" повторяется 3 раза
# а 'b' два раза
# а максимальное число будет 44433 берем вместо 'с' максимум в данной системе исчисления так как символа 'c' больше
